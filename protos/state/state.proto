/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

syntax = "proto3";

package state;

import "msgs/msgs.proto";

option go_package = "github.com/hyperledger-labs/mirbft/pkg/pb/state";

// Event represents a state event to be injected into the state machine
message Event {
    // TODO, normalize naming, for instance Complete/Completed
    oneof type {
        EventInitialParameters initialize = 1;
        EventLoadPersistedEntry load_persisted_entry = 2;
        EventLoadCompleted complete_initialization = 3;
        EventCheckpointResult checkpoint_result = 5;
        EventRequestPersisted request_persisted = 6;
        EventStateTransferComplete state_transfer_complete = 7;
        EventStateTransferFailed state_transfer_failed = 8;
        EventStep step = 9;
        EventTickElapsed tick_elapsed = 10;
        EventActionsReceived actions_received = 11;

        // Refactored. TODO: clean up the rest.
        //             TODO: polish the numbers.
        EventMessage message = 12;
        msgs.Request request = 13;
        EventHashRequest hash_request = 14;
        EventHashResult hash_result = 15;
        EventTick tick = 16;
        EventRequestReady request_ready = 17;
        EventSendMessage send_message = 18;
        EventMessageReceived message_received = 19;

        // Dummy events for testing purposes only.
        EventPersistDummyBatch persist_dummy_batch = 101;
        EventAnnounceDummyBatch announce_dummy_batch = 102;
    }

    // A list of follow-up events to process after this event has been processed.
    // This field is used if events need to be processed in a particular order.
    // For example, a message sending event must only be processed
    // after the corresponding entry has been persisted in the write-ahead log (WAL).
    // In this case, the WAL append event would be this event
    // and the next field would contain the message sending event.
    repeated Event next = 100;
}

message EventInitialParameters {
    uint64 id = 1;
    uint32 batch_size = 2;
    uint32 heartbeat_ticks = 3;
    uint32 suspect_ticks = 4;
    uint32 new_epoch_timeout_ticks = 5;
    uint32 buffer_size = 6;
}

message EventLoadPersistedEntry {
    uint64 index = 1;
    msgs.Persistent entry = 2;
}

message EventLoadCompleted {}

message EventCheckpointResult {
        uint64 seq_no = 1;
        bytes value = 2;
        msgs.NetworkState network_state = 3;
	bool reconfigured = 4;
}

message EventRequestPersisted {
    msgs.RequestAck request_ack = 1;
}

message EventStateTransferComplete {
    uint64 seq_no = 1;
    bytes checkpoint_value = 2;
    msgs.NetworkState network_state = 3;
}

message EventStateTransferFailed {
    uint64 seq_no = 1;
    bytes checkpoint_value = 2;
}

message EventStep {
    uint64 source = 1;
    msgs.Msg msg = 2;
}

message EventTickElapsed {}

message EventActionsReceived{}

message Action {
    oneof type {
       ActionSend send = 1;
       ActionHashRequest hash = 2;
       ActionWrite append_write_ahead = 3;
       ActionTruncate truncate_write_ahead = 4;
       ActionCommit commit = 5;
       ActionCheckpoint checkpoint = 6;
       ActionRequestSlot allocated_request = 7;
       msgs.RequestAck correct_request = 8;
       ActionForward forward_request = 9;
       ActionStateTarget state_transfer = 10;
       ActionStateApplied state_applied = 11;
    }
}

message ActionSend {
    repeated uint64 targets = 1;
    msgs.Msg msg = 2;
}

message ActionTruncate {
    uint64 index = 1;
}

message ActionWrite {
    uint64 index = 1;
    msgs.Persistent data = 2;
}

message ActionCommit {
    msgs.QEntry batch = 1;
}

message ActionCheckpoint {
    uint64 seq_no = 2;
    msgs.NetworkState.Config network_config = 3;
    repeated msgs.NetworkState.Client client_states = 4;
}

message ActionRequestSlot {
    uint64 client_id = 1;
    uint64 req_no = 2;
}

message ActionForward {
    repeated uint64 targets = 1;
    msgs.RequestAck ack = 2;
}

message ActionStateApplied {
    uint64 seq_no = 1;
    msgs.NetworkState network_state = 2;
}

message ActionHashRequest {
    repeated bytes data = 1;
    HashOrigin origin = 2;
}

message ActionStateTarget {
    uint64 seq_no = 1;
    bytes value = 2;
}

// Refactored. TODO: Clean up the rest above.

message EventTick {}

message EventMessage {
    uint64 source = 1;
    msgs.Msg msg = 2;
}

message EventHashRequest {
    repeated bytes data = 1;
    HashOrigin origin = 2;
}

message EventHashResult {
    bytes digest = 1;
    HashOrigin origin = 2;
}

message HashOrigin {
    oneof type {
        msgs.Request request = 1;

        // TODO: Get rid of these.
        Batch batch = 991;
        EpochChange epoch_change = 992;
        VerifyBatch verify_batch = 993;
    }

    // TODO: Get rid of Batch, VerifyBatch, and EpochChange
    message Batch {
        uint64 source = 1;
        uint64 epoch = 2;
        uint64 seq_no = 3;
        repeated msgs.RequestAck request_acks = 5;
    }

    message VerifyBatch {
        uint64 source = 1;
        uint64 seq_no = 2;
        repeated msgs.RequestAck request_acks = 3;
        bytes expected_digest = 4;
    }

    message EpochChange {
        uint64 source = 1;
        uint64 origin = 2;
        msgs.EpochChange epoch_change = 3;
    }
}

message EventRequestReady {
    msgs.RequestRef request_ref = 1;
}

message EventPersistDummyBatch {
    uint64 sn = 1;
    msgs.Batch batch = 2;
}

message EventAnnounceDummyBatch {
    uint64 sn = 1;
    msgs.Batch batch = 2;
}

message EventSendMessage {
    repeated uint64 destinations = 1;
    msgs.Message msg = 2;
}

message EventMessageReceived {
    uint64 from = 1;
    msgs.Message msg = 2;
}