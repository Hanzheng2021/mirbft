/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package ordering

import (
	"fmt"
	"github.com/hyperledger-labs/mirbft/pkg/events"
	"github.com/hyperledger-labs/mirbft/pkg/logger"
	"github.com/hyperledger-labs/mirbft/pkg/pb/eventpb"
	"github.com/hyperledger-labs/mirbft/pkg/pb/messagepb"
	"github.com/hyperledger-labs/mirbft/pkg/status"
)

// DummyProtocol is a stub for a protocol state machine implementation.
type DummyProtocol struct {
	logger logger.Logger

	membership    []uint64 // List of all replica IDs
	ownId         uint64   // Own replica ID
	otherReplicas []uint64 // List of all replica IDs except the own ID

	nextSn uint64 // Sequence number to assign to the next batch.
}

// NewDummyProtocol creates and returns a pointer to a new instance of DummyProtocol.
// Log output generated by this instance will be directed to logger.
func NewDummyProtocol(logger logger.Logger, initialMembership []uint64, ownId uint64) *DummyProtocol {

	// Compute a list of all other replica IDs (whole membership except the own ID)
	otherReplicas := make([]uint64, 0)
	for _, id := range initialMembership {
		if id != ownId {
			otherReplicas = append(otherReplicas, id)
		}
	}

	// Return an initialized DummyProtocol
	return &DummyProtocol{
		logger:        logger,
		membership:    initialMembership,
		ownId:         ownId,
		otherReplicas: otherReplicas,
	}
}

// ApplyEvent applies an event to the protocol state machine, deterministically advancing its state
// and generating a (possibly empty) list of output events.
func (dsm *DummyProtocol) ApplyEvent(event *eventpb.Event) *events.EventList {
	switch e := event.Type.(type) {
	case *eventpb.Event_PersistDummyBatch:
		dsm.logger.Log(logger.LevelDebug, "Loading dummy batch from WAL.")
	case *eventpb.Event_Message:
		dsm.logger.Log(logger.LevelDebug, "Message event.")
	case *eventpb.Event_Tick:
		// Do nothing in the dummy SM.
	case *eventpb.Event_RequestReady:
		return dsm.handleRequest(e.RequestReady.RequestRef)
	case *eventpb.Event_MessageReceived:
		return dsm.handleMessage(e.MessageReceived.Msg, e.MessageReceived.From)
	default:
		panic(fmt.Sprintf("unknown state machine event type: %T", event.Type))
	}

	return &events.EventList{}
}

// Status returns an empty protocol state. This function a stub in the dummy protocol implementation.
func (dsm *DummyProtocol) Status() (s *status.StateMachine, err error) {
	return &status.StateMachine{}, nil
}

// Handles a new incoming request.
// In the DummyProtocol, the leader (always node 0) commits it directly
// and forwards it to all replicas, also persisting these steps in the WAL.
// Non-leaders ignore incoming requests.
func (dsm *DummyProtocol) handleRequest(ref *messagepb.RequestRef) *events.EventList {

	if dsm.ownId == 0 {
		// If I am the leader, handle request.
		dsm.logger.Log(logger.LevelDebug, "Handling Request.", "clientId", ref.ClientId, "reqNo", ref.ReqNo)

		// Get the sequence number for the new batch
		sn := dsm.nextSn
		dsm.nextSn++

		// Create a dummy wrapper batch containing only this request.
		batch := &messagepb.Batch{Requests: []*messagepb.RequestRef{ref}}

		// Create event for persisting the request (wrapped in a batch) in the WAL.
		walEvent := events.PersistDummyBatch(sn, batch)

		// Create event for committing the request (wrapped in a batch).
		announceEvent := events.AnnounceDummyBatch(sn, batch)

		// Create message sending event for forwarding this single-request batch to other replicas.
		msgSendEvent := events.SendMessage(&messagepb.Message{Type: &messagepb.Message_DummyPreprepare{
			DummyPreprepare: &messagepb.DummyPreprepare{
				Sn:    sn,
				Batch: batch,
			},
		}}, dsm.otherReplicas)

		// First the dummy batch needs to be persisted to the WAL, and only then it can be committed and sent to others.
		walEvent.Next = []*eventpb.Event{announceEvent, msgSendEvent}
		return (&events.EventList{}).PushBack(walEvent)
	} else {
		// If I am not the leader (node 0 is always the leader in DummyProtocol), ignore incoming requests.

		dsm.logger.Log(logger.LevelDebug, "Non-leader ignoring request.",
			"clientId", ref.ClientId, "reqNo", ref.ReqNo)
		return &events.EventList{}
	}
}

// Handles an incoming protocol message.
// This dummy implementation only knows one type of message - a direct message from the leader containing a batch.
// handleMessage directly announces each batch to the application.
func (dsm *DummyProtocol) handleMessage(message *messagepb.Message, from uint64) *events.EventList {
	switch msg := message.Type.(type) {

	case *messagepb.Message_DummyPreprepare:
		// Announce incoming batch directly.
		return (&events.EventList{}).PushBack(
			events.AnnounceDummyBatch(msg.DummyPreprepare.Sn, msg.DummyPreprepare.Batch))

	default:
		// Panic if message type is not known.
		panic(fmt.Sprintf("unknown DummyProtocol message type (from %d): %T", from, message.Type))
	}
}
