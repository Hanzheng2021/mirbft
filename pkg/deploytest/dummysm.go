/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0

Refactored: 1
*/

package deploytest

import (
	"fmt"
	"github.com/hyperledger-labs/mirbft/pkg/events"
	"github.com/hyperledger-labs/mirbft/pkg/logger"
	"github.com/hyperledger-labs/mirbft/pkg/pb/msgs"
	"github.com/hyperledger-labs/mirbft/pkg/pb/state"
	"github.com/hyperledger-labs/mirbft/pkg/status"
)

// DummySM is a stub for a protocol state machine implementation.
type DummySM struct {
	logger logger.Logger

	membership    []uint64 // List of all replica IDs
	ownId         uint64   // Own replica ID
	otherReplicas []uint64 // List of all replica IDs except the own ID

	nextSn uint64 // Sequence number to assign to the next batch.
}

// NewDummySM creates and returns a pointer to a new instance of DummySM.
// Log output generated by this instance will be directed to logger.
func NewDummySM(logger logger.Logger, initialMembership []uint64, ownId uint64) *DummySM {

	// Compute a list of all other replica IDs (whole membership except the own ID)
	otherReplicas := make([]uint64, 0)
	for _, id := range otherReplicas {
		if id != ownId {
			otherReplicas = append(otherReplicas, id)
		}
	}

	// Return an initialized DummySM
	return &DummySM{
		logger:        logger,
		membership:    initialMembership,
		ownId:         ownId,
		otherReplicas: otherReplicas,
	}
}

// ApplyEvent applies an event to the state machine, deterministically advancing its state
// and generating a (possibly empty) list of output events.
func (dsm *DummySM) ApplyEvent(event *state.Event) *events.EventList {
	switch e := event.Type.(type) {
	case *state.Event_Message:
		dsm.logger.Log(logger.LevelDebug, "Message event.")
	case *state.Event_Tick:
		dsm.logger.Log(logger.LevelDebug, "Tick elapsed.")
	case *state.Event_RequestReady:
		dsm.logger.Log(logger.LevelDebug, "Request ready.",
			"clientId", e.RequestReady.RequestRef.ClientId, "reqNo", e.RequestReady.RequestRef.ReqNo)
		return dsm.handleRequest(e.RequestReady.RequestRef)
	default:
		panic(fmt.Sprintf("unknown state machine event type: %T", event.Type))
	}

	return &events.EventList{}
}

// Status returns an empty state machine state.
func (dsm *DummySM) Status() (s *status.StateMachine, err error) {
	return &status.StateMachine{}, nil
}

// Handles a new incoming request.
// In the DummySM, commits it directly and forwards it to all replicas, also persisting these steps in the WAL.
func (dsm *DummySM) handleRequest(ref *msgs.RequestRef) *events.EventList {

	dsm.logger.Log(logger.LevelDebug, "Handling Request.")

	// Get the sequence number for the new batch
	sn := dsm.nextSn
	dsm.nextSn++

	// Create a dummy wrapper batch containing only this request.
	batch := &msgs.Batch{Requests: []*msgs.RequestRef{ref}}

	// Create event for persisting the request (wrapped in a batch) in the WAL.
	walEvent := events.PersistDummyBatch(sn, batch)

	// Create event for committing the request (wrapped in a batch).
	announceEvent := events.AnnounceDummyBatch(sn, batch)

	// Create message sending event for forwarding this single-request batch to other replicas.
	msgSendEvent := events.SendMessage(&msgs.Message{Type: &msgs.Message_DummyPreprepare{
		DummyPreprepare: &msgs.DummyPreprepare{
			Sn:    sn,
			Batch: batch,
		},
	}}, dsm.otherReplicas)

	// First the the dummy batch needs to be persisted to the WAL, and only then it can be committed and sent to others.
	walEvent.Next = []*state.Event{announceEvent, msgSendEvent}

	return (&events.EventList{}).PushBack(walEvent)
}
